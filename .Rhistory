vp$v_sigma <- abs(mvrnorm(n = model$D, rep(0,model$K),diag(rep(1,model$K))))
return(vp)
}
likely <- function(X_t,U,V,D){
ll <- 0
for (i in 1:model$D) {
for (j in 1:model$D) {
u <- U[i,]
v <- V[j,]
x <- t(u) %*% v
sig <- log(1/(1 + exp(-x)))
gauche <- X_t$P[i,j] * sig
sig <- log(1/(1 + exp(x)))
droite <- X_t$N[i,j] * sig
droite <- 0
ll <- ll + gauche + droite
}
ll <- ll +  log(dmvnorm(U[i,],rep(0,model$K),diag(rep(1,model$K))))
ll <- ll +  log(dmvnorm(V[i,],rep(0,model$K),diag(rep(1,model$K))))
}
return(ll)
}
source("model.R")
source("utils.R")
# (D,K,sigma_t,sigma_0,nb_epochs,nb_MB,nb_sampleVI)
n <- 20
model <- init_model(n,2,1,1,10,3,500)
model$timePosition
X_t <- list()
# GenerateData
K = 3
alpha = rep(1/K, K)
intra <- 0.8
inter <- (1 - intra)/(K-1)
pi = matrix(inter, K, K)
diag(pi) = intra
e <- 50000
rSBM <- randomSBM(n,e,K,alpha,pi)
rSBM$Adj
# rSBM$cluster
X_t$P <- as.matrix(rSBM$Adj)
X_t$N <- max(X_t$P) - X_t$P
# View(X_t$N)
den <- mean(X_t$N)/round((sum(X_t$P) * 1) / (n * n))
X_t$N <- round(X_t$N / den)
# View(X_t$P)
# View(X_t$N)
# X_t$N <- 5 * round((rowSums(X_t$P) %*% t(colSums(X_t$P))) / sum(X_t$P))
# sum(X_t$N)
# X_t$N
# e
# debug(optim)
# debug(likelyVar)
blob <- optim(X_t,model,rSBM$cluster)
plot(blob$ll)
library(mixtools)
optim <- function(X_t,model,color){
logLout <- c()
vp <- draw_VP_withoutSigma(model)
Ut <- vp$u_mu
plot(Ut,col = color)
logL <- likely(X_t,Ut,Ut,model$D)
print(logL)
for (epo in 1:model$nb_epochs) {
print(paste("eopch :",epo))
# epo <- 1
grad_mu_u <- matrix(0,model$D,model$K)
grad_sigma_u <- matrix(0,model$D,model$K)
for (i in 1:model$D) {
for (samp in 1:model$nb_sampleVI) {
u <- mvrnorm(n = 1,vp$u_mu[i,],diag(vp$u_sigma[i,]))
ll <- 0
for (j in 1:model$D) {
v <- vp$u_mu[j,]
x <- t(u) %*% v
sig <- 1/(1 + exp(-x))
gauche <- X_t$P[i,j] * log(sig)
sig <- 1/(1 + exp(x))
droite <- X_t$N[i,j] * log(sig)
droite <- 0
ll <- ll + gauche + droite
}
grad_mu_u[i,] <-  grad_mu_u[i,] + ((u - vp$u_mu[i,])  * ll)
a <- 0.5 * (((u - vp$u_mu[i,])^2 - vp$u_sigma[i,])/vp$u_sigma[i,]^2) * ll
grad_sigma_u[i,] <-  grad_sigma_u[i,] + a
}
grad_mu_u[i,] <- grad_mu_u[i,] / model$nb_sampleVI - 1
vp$u_mu[i,] <- vp$u_mu[i,] + 0.00005 * grad_mu_u[i,]
grad_sigma_u[i,] <- grad_sigma_u[i,] / model$nb_sampleVI + 0.5*((1 / vp$u_sigma[i,]) - (1/1))
vp$u_sigma[i,] <- grad_sigma_u[i,] + 0.000005 * vp$u_sigma[i,]
}
Ut <- vp$u_mu
logL <- likely(X_t,Ut,Ut,model$D)
print(logL)
logLout <- c(logLout,logL)
plot(Ut,col = color)
} # epo
model$timePosition <- model$timePosition + 1
# return(model,logLout)
return(list(embedding = Ut,ll=logLout,sigma = vp$u_sigma))
}
draw_VP_withoutSigma <- function(model){
vp <- list()
vp$u_mu <- mvrnorm(n = model$D, rep(0,model$K),diag(rep(0.1,model$K)))
vp$v_mu <- mvrnorm(n = model$D, rep(0,model$K),diag(rep(0.1,model$K)))
vp$u_sigma <- matrix(1,model$D,model$K)
vp$v_sigma <- matrix(1,model$D,model$K)
return(vp)
}
draw_VP <- function(model){
vp <- list()
vp$u_mu <- mvrnorm(n = model$D, rep(0,model$K),diag(rep(1,model$K)))
vp$v_mu <- mvrnorm(n = model$D, rep(0,model$K),diag(rep(1,model$K)))
vp$u_sigma <- abs(mvrnorm(n = model$D, rep(0,model$K),diag(rep(1,model$K))))
vp$v_sigma <- abs(mvrnorm(n = model$D, rep(0,model$K),diag(rep(1,model$K))))
return(vp)
}
likely <- function(X_t,U,V,D){
ll <- 0
for (i in 1:model$D) {
for (j in 1:model$D) {
u <- U[i,]
v <- V[j,]
x <- t(u) %*% v
sig <- log(1/(1 + exp(-x)))
gauche <- X_t$P[i,j] * sig
sig <- log(1/(1 + exp(x)))
droite <- X_t$N[i,j] * sig
droite <- 0
ll <- ll + gauche + droite
}
ll <- ll +  log(dmvnorm(U[i,],rep(0,model$K),diag(rep(1,model$K))))
ll <- ll +  log(dmvnorm(V[i,],rep(0,model$K),diag(rep(1,model$K))))
}
return(ll)
}
source("model.R")
source("utils.R")
# (D,K,sigma_t,sigma_0,nb_epochs,nb_MB,nb_sampleVI)
n <- 20
model <- init_model(n,2,1,1,10,3,500)
model$timePosition
X_t <- list()
# GenerateData
K = 3
alpha = rep(1/K, K)
intra <- 0.8
inter <- (1 - intra)/(K-1)
pi = matrix(inter, K, K)
diag(pi) = intra
e <- 50000
rSBM <- randomSBM(n,e,K,alpha,pi)
rSBM$Adj
# rSBM$cluster
X_t$P <- as.matrix(rSBM$Adj)
X_t$N <- max(X_t$P) - X_t$P
# View(X_t$N)
den <- mean(X_t$N)/round((sum(X_t$P) * 1) / (n * n))
X_t$N <- round(X_t$N / den)
# View(X_t$P)
# View(X_t$N)
# X_t$N <- 5 * round((rowSums(X_t$P) %*% t(colSums(X_t$P))) / sum(X_t$P))
# sum(X_t$N)
# X_t$N
# e
debug(optim)
# debug(likelyVar)
blob <- optim(X_t,model,rSBM$cluster)
plot(blob$ll)
View(grad_sigma_u)
library(mixtools)
optim <- function(X_t,model,color){
logLout <- c()
vp <- draw_VP_withoutSigma(model)
Ut <- vp$u_mu
plot(Ut,col = color)
logL <- likely(X_t,Ut,Ut,model$D)
print(logL)
for (epo in 1:model$nb_epochs) {
print(paste("eopch :",epo))
# epo <- 1
grad_mu_u <- matrix(0,model$D,model$K)
grad_sigma_u <- matrix(0,model$D,model$K)
for (i in 1:model$D) {
for (samp in 1:model$nb_sampleVI) {
u <- mvrnorm(n = 1,vp$u_mu[i,],diag(vp$u_sigma[i,]))
ll <- 0
for (j in 1:model$D) {
v <- vp$u_mu[j,]
x <- t(u) %*% v
sig <- 1/(1 + exp(-x))
gauche <- X_t$P[i,j] * log(sig)
sig <- 1/(1 + exp(x))
droite <- X_t$N[i,j] * log(sig)
droite <- 0
ll <- ll + gauche + droite
}
grad_mu_u[i,] <-  grad_mu_u[i,] + ((u - vp$u_mu[i,])  * ll)
a <- 0.5 * (((u - vp$u_mu[i,])^2 - vp$u_sigma[i,])/vp$u_sigma[i,]^2) * ll
grad_sigma_u[i,] <-  grad_sigma_u[i,] + a
}
grad_mu_u[i,] <- grad_mu_u[i,] / model$nb_sampleVI - 1
vp$u_mu[i,] <- vp$u_mu[i,] + 0.00005 * grad_mu_u[i,]
grad_sigma_u[i,] <- grad_sigma_u[i,] / model$nb_sampleVI + 0.5*((1 / vp$u_sigma[i,]) - (1/1))
vp$u_sigma[i,] <- grad_sigma_u[i,] + 0.00000005 * vp$u_sigma[i,]
}
Ut <- vp$u_mu
logL <- likely(X_t,Ut,Ut,model$D)
print(logL)
logLout <- c(logLout,logL)
plot(Ut,col = color)
} # epo
model$timePosition <- model$timePosition + 1
# return(model,logLout)
return(list(embedding = Ut,ll=logLout,sigma = vp$u_sigma))
}
draw_VP_withoutSigma <- function(model){
vp <- list()
vp$u_mu <- mvrnorm(n = model$D, rep(0,model$K),diag(rep(0.1,model$K)))
vp$v_mu <- mvrnorm(n = model$D, rep(0,model$K),diag(rep(0.1,model$K)))
vp$u_sigma <- matrix(1,model$D,model$K)
vp$v_sigma <- matrix(1,model$D,model$K)
return(vp)
}
draw_VP <- function(model){
vp <- list()
vp$u_mu <- mvrnorm(n = model$D, rep(0,model$K),diag(rep(1,model$K)))
vp$v_mu <- mvrnorm(n = model$D, rep(0,model$K),diag(rep(1,model$K)))
vp$u_sigma <- abs(mvrnorm(n = model$D, rep(0,model$K),diag(rep(1,model$K))))
vp$v_sigma <- abs(mvrnorm(n = model$D, rep(0,model$K),diag(rep(1,model$K))))
return(vp)
}
likely <- function(X_t,U,V,D){
ll <- 0
for (i in 1:model$D) {
for (j in 1:model$D) {
u <- U[i,]
v <- V[j,]
x <- t(u) %*% v
sig <- log(1/(1 + exp(-x)))
gauche <- X_t$P[i,j] * sig
sig <- log(1/(1 + exp(x)))
droite <- X_t$N[i,j] * sig
droite <- 0
ll <- ll + gauche + droite
}
ll <- ll +  log(dmvnorm(U[i,],rep(0,model$K),diag(rep(1,model$K))))
ll <- ll +  log(dmvnorm(V[i,],rep(0,model$K),diag(rep(1,model$K))))
}
return(ll)
}
source("model.R")
source("utils.R")
# (D,K,sigma_t,sigma_0,nb_epochs,nb_MB,nb_sampleVI)
n <- 20
model <- init_model(n,2,1,1,10,3,500)
model$timePosition
X_t <- list()
# GenerateData
K = 3
alpha = rep(1/K, K)
intra <- 0.8
inter <- (1 - intra)/(K-1)
pi = matrix(inter, K, K)
diag(pi) = intra
e <- 50000
rSBM <- randomSBM(n,e,K,alpha,pi)
rSBM$Adj
# rSBM$cluster
X_t$P <- as.matrix(rSBM$Adj)
X_t$N <- max(X_t$P) - X_t$P
# View(X_t$N)
den <- mean(X_t$N)/round((sum(X_t$P) * 1) / (n * n))
X_t$N <- round(X_t$N / den)
# View(X_t$P)
# View(X_t$N)
# X_t$N <- 5 * round((rowSums(X_t$P) %*% t(colSums(X_t$P))) / sum(X_t$P))
# sum(X_t$N)
# X_t$N
# e
debug(optim)
# debug(likelyVar)
blob <- optim(X_t,model,rSBM$cluster)
plot(blob$ll)
library(mixtools)
optim <- function(X_t,model,color){
logLout <- c()
vp <- draw_VP_withoutSigma(model)
Ut <- vp$u_mu
plot(Ut,col = color)
logL <- likely(X_t,Ut,Ut,model$D)
print(logL)
for (epo in 1:model$nb_epochs) {
print(paste("eopch :",epo))
# epo <- 1
grad_mu_u <- matrix(0,model$D,model$K)
grad_sigma_u <- matrix(0,model$D,model$K)
for (i in 1:model$D) {
for (samp in 1:model$nb_sampleVI) {
u <- mvrnorm(n = 1,vp$u_mu[i,],diag(vp$u_sigma[i,]))
ll <- 0
for (j in 1:model$D) {
v <- vp$u_mu[j,]
x <- t(u) %*% v
sig <- 1/(1 + exp(-x))
gauche <- X_t$P[i,j] * log(sig)
sig <- 1/(1 + exp(x))
droite <- X_t$N[i,j] * log(sig)
droite <- 0
ll <- ll + gauche + droite
}
grad_mu_u[i,] <-  grad_mu_u[i,] + ((u - vp$u_mu[i,])  * ll)
a <- 0.5 * (((u - vp$u_mu[i,])^2 - vp$u_sigma[i,])/vp$u_sigma[i,]^2) * ll
grad_sigma_u[i,] <-  grad_sigma_u[i,] + a
}
grad_mu_u[i,] <- grad_mu_u[i,] / model$nb_sampleVI - 1
vp$u_mu[i,] <- vp$u_mu[i,] + 0.00005 * grad_mu_u[i,]
grad_sigma_u[i,] <- grad_sigma_u[i,] / model$nb_sampleVI + 0.5*((1 / vp$u_sigma[i,]) - (1/1))
# vp$u_sigma[i,] <- grad_sigma_u[i,] + 0.00000005 * vp$u_sigma[i,]
}
Ut <- vp$u_mu
logL <- likely(X_t,Ut,Ut,model$D)
print(logL)
logLout <- c(logLout,logL)
plot(Ut,col = color)
} # epo
model$timePosition <- model$timePosition + 1
# return(model,logLout)
return(list(embedding = Ut,ll=logLout,sigma = vp$u_sigma))
}
draw_VP_withoutSigma <- function(model){
vp <- list()
vp$u_mu <- mvrnorm(n = model$D, rep(0,model$K),diag(rep(0.1,model$K)))
vp$v_mu <- mvrnorm(n = model$D, rep(0,model$K),diag(rep(0.1,model$K)))
vp$u_sigma <- matrix(1,model$D,model$K)
vp$v_sigma <- matrix(1,model$D,model$K)
return(vp)
}
draw_VP <- function(model){
vp <- list()
vp$u_mu <- mvrnorm(n = model$D, rep(0,model$K),diag(rep(1,model$K)))
vp$v_mu <- mvrnorm(n = model$D, rep(0,model$K),diag(rep(1,model$K)))
vp$u_sigma <- abs(mvrnorm(n = model$D, rep(0,model$K),diag(rep(1,model$K))))
vp$v_sigma <- abs(mvrnorm(n = model$D, rep(0,model$K),diag(rep(1,model$K))))
return(vp)
}
likely <- function(X_t,U,V,D){
ll <- 0
for (i in 1:model$D) {
for (j in 1:model$D) {
u <- U[i,]
v <- V[j,]
x <- t(u) %*% v
sig <- log(1/(1 + exp(-x)))
gauche <- X_t$P[i,j] * sig
sig <- log(1/(1 + exp(x)))
droite <- X_t$N[i,j] * sig
droite <- 0
ll <- ll + gauche + droite
}
ll <- ll +  log(dmvnorm(U[i,],rep(0,model$K),diag(rep(1,model$K))))
ll <- ll +  log(dmvnorm(V[i,],rep(0,model$K),diag(rep(1,model$K))))
}
return(ll)
}
source("model.R")
source("utils.R")
# (D,K,sigma_t,sigma_0,nb_epochs,nb_MB,nb_sampleVI)
n <- 20
model <- init_model(n,2,1,1,10,3,500)
model$timePosition
X_t <- list()
# GenerateData
K = 3
alpha = rep(1/K, K)
intra <- 0.8
inter <- (1 - intra)/(K-1)
pi = matrix(inter, K, K)
diag(pi) = intra
e <- 50000
rSBM <- randomSBM(n,e,K,alpha,pi)
rSBM$Adj
# rSBM$cluster
X_t$P <- as.matrix(rSBM$Adj)
X_t$N <- max(X_t$P) - X_t$P
# View(X_t$N)
den <- mean(X_t$N)/round((sum(X_t$P) * 1) / (n * n))
X_t$N <- round(X_t$N / den)
# View(X_t$P)
# View(X_t$N)
# X_t$N <- 5 * round((rowSums(X_t$P) %*% t(colSums(X_t$P))) / sum(X_t$P))
# sum(X_t$N)
# X_t$N
# e
debug(optim)
# debug(likelyVar)
blob <- optim(X_t,model,rSBM$cluster)
plot(blob$ll)
library(mixtools)
optim <- function(X_t,model,color){
logLout <- c()
vp <- draw_VP_withoutSigma(model)
Ut <- vp$u_mu
plot(Ut,col = color)
logL <- likely(X_t,Ut,Ut,model$D)
print(logL)
for (epo in 1:model$nb_epochs) {
print(paste("eopch :",epo))
# epo <- 1
grad_mu_u <- matrix(0,model$D,model$K)
grad_sigma_u <- matrix(0,model$D,model$K)
for (i in 1:model$D) {
for (samp in 1:model$nb_sampleVI) {
u <- mvrnorm(n = 1,vp$u_mu[i,],diag(vp$u_sigma[i,]))
ll <- 0
for (j in 1:model$D) {
v <- vp$u_mu[j,]
x <- t(u) %*% v
sig <- 1/(1 + exp(-x))
gauche <- X_t$P[i,j] * log(sig)
sig <- 1/(1 + exp(x))
droite <- X_t$N[i,j] * log(sig)
droite <- 0
ll <- ll + gauche + droite
}
grad_mu_u[i,] <-  grad_mu_u[i,] + ((u - vp$u_mu[i,])  * ll)
a <- 0.5 * (((u - vp$u_mu[i,])^2 - vp$u_sigma[i,])/vp$u_sigma[i,]^2) * ll
grad_sigma_u[i,] <-  grad_sigma_u[i,] + a
}
grad_mu_u[i,] <- grad_mu_u[i,] / model$nb_sampleVI - 1
vp$u_mu[i,] <- vp$u_mu[i,] + 0.00005 * grad_mu_u[i,]
grad_sigma_u[i,] <- grad_sigma_u[i,] / model$nb_sampleVI + 0.5*((1 / vp$u_sigma[i,]) - (1/1))
# vp$u_sigma[i,] <- grad_sigma_u[i,] + 0.00000005 * vp$u_sigma[i,]
}
Ut <- vp$u_mu
logL <- likely(X_t,Ut,Ut,model$D)
print(logL)
logLout <- c(logLout,logL)
plot(Ut,col = color)
} # epo
model$timePosition <- model$timePosition + 1
# return(model,logLout)
return(list(embedding = Ut,ll=logLout,sigma = vp$u_sigma))
}
draw_VP_withoutSigma <- function(model){
vp <- list()
vp$u_mu <- mvrnorm(n = model$D, rep(0,model$K),diag(rep(0.1,model$K)))
vp$v_mu <- mvrnorm(n = model$D, rep(0,model$K),diag(rep(0.1,model$K)))
vp$u_sigma <- matrix(1,model$D,model$K)
vp$v_sigma <- matrix(1,model$D,model$K)
return(vp)
}
draw_VP <- function(model){
vp <- list()
vp$u_mu <- mvrnorm(n = model$D, rep(0,model$K),diag(rep(1,model$K)))
vp$v_mu <- mvrnorm(n = model$D, rep(0,model$K),diag(rep(1,model$K)))
vp$u_sigma <- abs(mvrnorm(n = model$D, rep(0,model$K),diag(rep(1,model$K))))
vp$v_sigma <- abs(mvrnorm(n = model$D, rep(0,model$K),diag(rep(1,model$K))))
return(vp)
}
likely <- function(X_t,U,V,D){
ll <- 0
for (i in 1:model$D) {
for (j in 1:model$D) {
u <- U[i,]
v <- V[j,]
x <- t(u) %*% v
sig <- log(1/(1 + exp(-x)))
gauche <- X_t$P[i,j] * sig
sig <- log(1/(1 + exp(x)))
droite <- X_t$N[i,j] * sig
droite <- 0
ll <- ll + gauche + droite
}
ll <- ll +  log(dmvnorm(U[i,],rep(0,model$K),diag(rep(1,model$K))))
ll <- ll +  log(dmvnorm(V[i,],rep(0,model$K),diag(rep(1,model$K))))
}
return(ll)
}
source("model.R")
source("utils.R")
# (D,K,sigma_t,sigma_0,nb_epochs,nb_MB,nb_sampleVI)
n <- 20
model <- init_model(n,2,1,1,10,3,500)
model$timePosition
X_t <- list()
# GenerateData
K = 3
alpha = rep(1/K, K)
intra <- 0.8
inter <- (1 - intra)/(K-1)
pi = matrix(inter, K, K)
diag(pi) = intra
e <- 50000
rSBM <- randomSBM(n,e,K,alpha,pi)
rSBM$Adj
# rSBM$cluster
X_t$P <- as.matrix(rSBM$Adj)
X_t$N <- max(X_t$P) - X_t$P
# View(X_t$N)
den <- mean(X_t$N)/round((sum(X_t$P) * 1) / (n * n))
X_t$N <- round(X_t$N / den)
# View(X_t$P)
# View(X_t$N)
# X_t$N <- 5 * round((rowSums(X_t$P) %*% t(colSums(X_t$P))) / sum(X_t$P))
# sum(X_t$N)
# X_t$N
# e
debug(optim)
# debug(likelyVar)
blob <- optim(X_t,model,rSBM$cluster)
plot(blob$ll)
